{
    "docs": [
        {
            "location": "/",
            "text": "PyPathway\n\n\nintegrated Python toolkit for pathway based analysis\n\n\n\n\n\n\n\n\n\n\n\n\nInstallation\n\n\nGeneral requirement\n\n\nPython version: >= 3.5\n\n\nWindows\n\n\n\n\n\n\nThe \nVisual C++ 2015 Build Tools\n is required to compile c extensions.\n\n\n\n\n\n\nnumpy\n, \nscipy\n and \nstaticmodels\n (anaconda is recommend)\n\n\n\n\n\n\nUnix / Linux\n\n\n\n\ngcc or clang compiler\n\n\n\n\nSources\n\n\n\n\ninstall via pypi\n\n\n\n\npip install pypathway\n\n\n\n\n\n\ninstall from the source\n\n\n\n\ngit clone https://github.com/iseekwonderful/PyPathway.git\ncd PyPathway\npython setup.py install\n\n\n\n\nFeatures\n\n\n\n\nPublic databases APIs: \nSTRING\n, \nBioGRID\n, \nKEGG\n, \nReactome\n and \nWikiPathway\n\n\nFunctional set based and network based enrichment analysis algorithms implemented: \nORA\n, \nGSEA\n and \nSPIA\n\n\nPerformance optimize for denovo enrichment algorithm \nMAGI\n and \nHotnet2\n.\n\n\nNetwork propagation random walk, RWR and heat kernel\n\n\nInteractive visualization for pathway, graph and analysis result.\n\n\n\n\nWeb page exportation for results.\n\n\n\n\n\n\nIntegrated with pandas, networkx and numpy. Most of the methods accept both text file and data structure from these packages \n\n\n\n\nDynamic visualization for IPython notebook. \n\n\nMost classes implement \n__repr__\n method for interactive environment.\n\n\n\n\nNetwork process\n\n\nIntuitive APIs for querying and retrieval interaction network from public database. The return object are stored in \nnetworkx.Graph\n object.\n\n\nSupport databases\n\n\n\n\nKEGG\n\n\nReactome\n\n\nWikiPathway\n\n\nSTRING\n\n\nBioGRID\n\n\n\n\nSearch\n\n\nfrom pypathway import PublicDatabase\nkg = PublicDatabase.search_kegg('CD4')\nwp = PublicDatabase.search_wp('CD4')\nrt = PublicDatabase.search_reactome('CD4')\n\n\n\n\nLoad\n\n\npathway = r[0].load()\n\n\n\n\nPlot\n\n\npathway.draw()\n\n\n\n\n\n\nIPython notebook examples\n\n\n\n\nSTRING and BioGRID\n\n\nPathway databases\n\n\n\n\nEnrichment Analysis\n\n\nSupport methods\n\n\n\n\nORA\n\n\nGSEA\n\n\nNetwork enrichment (SPIA and Enrichment)\n\n\ndenovo enrichment (MAGI and Hotnet2)\n\n\n\n\nImplementation / Interface\n\n\n\n\nStaticmethod \nrun()\n for the starting of the analysis\n\n\n\n\nr = SPIA.run(all=c.background, de=c.deg, organism='hsa')\n\n\n\n\n\n\ntable\n, \nplot()\n and \ngraph()\n method for the presentation of the analysis\n\n\n\n\nres.table\n\n\n\n\n\n\n\nres.plot()\n\n\n\n\n\n\n\nres.graph()\n\n\n\n\n\n\nIPython examples\n\n\n\n\nORA\n\n\nGSEA\n\n\nNetwork enrichment\n\n\nMAGI\n\n\nHotnet2\n\n\n\n\nModeling\n\n\n\n\nthe Python Interface and optimize for \nMAGI\n\n\nseveral c extension for `Hotnet permutation performance \n\n\n\n\nPropagation\n\n\nImplemented algorithms\n\n\n\n\nRandom walk\n\n\n\n\n\nrandom_walk(G, h)\n\n\n\n\n\n\nRandom walk with restart\n\n\n\n\n\nrandom_walk_with_restart(G, h, rp=0.7, n=-1)\n\n\n\n\n\n\nHeat kernel\n\n\n\n\ndiffusion_kernel(G, h, rp=0.8, n=100)\n\n\n\n\n\ndetail\n\n\n\n\n\n\n\n\nimage source: \nNetwork propagation: a universal amplifier of genetic associations\n\n\nIPython notebook examples\n\n\n\n\nPropagation\n\n\n\n\nUtility and Performance\n\n\n\n\nThe Id converter\n\n\nGMT file manager\n\n\nnetwork and expression data sets.\n\n\nnumpy implementation of SPIA\n\n\nnode swap c extension for Hotnet2\n\n\nmulti-threading for MAGI\n\n\n\n\nInteractive Visualization\n\n\nThe interactive visualization for IPython notebook\n\n\nFeature\n\n\n\n\n__repr__\n Implemented for most classes\n\n\ndynamic visualization for networkx.Graph instance\n\n\nvisualizer for pathway object\n\n\nvisualizer for Gene ontology DAG.",
            "title": "Overview"
        },
        {
            "location": "/#pypathway",
            "text": "integrated Python toolkit for pathway based analysis",
            "title": "PyPathway"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#general-requirement",
            "text": "Python version: >= 3.5",
            "title": "General requirement"
        },
        {
            "location": "/#windows",
            "text": "The  Visual C++ 2015 Build Tools  is required to compile c extensions.    numpy ,  scipy  and  staticmodels  (anaconda is recommend)",
            "title": "Windows"
        },
        {
            "location": "/#unix-linux",
            "text": "gcc or clang compiler",
            "title": "Unix / Linux"
        },
        {
            "location": "/#sources",
            "text": "install via pypi   pip install pypathway   install from the source   git clone https://github.com/iseekwonderful/PyPathway.git\ncd PyPathway\npython setup.py install",
            "title": "Sources"
        },
        {
            "location": "/#features",
            "text": "Public databases APIs:  STRING ,  BioGRID ,  KEGG ,  Reactome  and  WikiPathway  Functional set based and network based enrichment analysis algorithms implemented:  ORA ,  GSEA  and  SPIA  Performance optimize for denovo enrichment algorithm  MAGI  and  Hotnet2 .  Network propagation random walk, RWR and heat kernel  Interactive visualization for pathway, graph and analysis result.   Web page exportation for results.    Integrated with pandas, networkx and numpy. Most of the methods accept both text file and data structure from these packages    Dynamic visualization for IPython notebook.   Most classes implement  __repr__  method for interactive environment.",
            "title": "Features"
        },
        {
            "location": "/#network-process",
            "text": "Intuitive APIs for querying and retrieval interaction network from public database. The return object are stored in  networkx.Graph  object.",
            "title": "Network process"
        },
        {
            "location": "/#support-databases",
            "text": "KEGG  Reactome  WikiPathway  STRING  BioGRID",
            "title": "Support databases"
        },
        {
            "location": "/#search",
            "text": "from pypathway import PublicDatabase\nkg = PublicDatabase.search_kegg('CD4')\nwp = PublicDatabase.search_wp('CD4')\nrt = PublicDatabase.search_reactome('CD4')",
            "title": "Search"
        },
        {
            "location": "/#load",
            "text": "pathway = r[0].load()",
            "title": "Load"
        },
        {
            "location": "/#plot",
            "text": "pathway.draw()",
            "title": "Plot"
        },
        {
            "location": "/#ipython-notebook-examples",
            "text": "STRING and BioGRID  Pathway databases",
            "title": "IPython notebook examples"
        },
        {
            "location": "/#enrichment-analysis",
            "text": "",
            "title": "Enrichment Analysis"
        },
        {
            "location": "/#support-methods",
            "text": "ORA  GSEA  Network enrichment (SPIA and Enrichment)  denovo enrichment (MAGI and Hotnet2)",
            "title": "Support methods"
        },
        {
            "location": "/#implementation-interface",
            "text": "Staticmethod  run()  for the starting of the analysis   r = SPIA.run(all=c.background, de=c.deg, organism='hsa')   table ,  plot()  and  graph()  method for the presentation of the analysis   res.table   res.plot()   \nres.graph()",
            "title": "Implementation / Interface"
        },
        {
            "location": "/#ipython-examples",
            "text": "ORA  GSEA  Network enrichment  MAGI  Hotnet2",
            "title": "IPython examples"
        },
        {
            "location": "/#modeling",
            "text": "the Python Interface and optimize for  MAGI  several c extension for `Hotnet permutation performance",
            "title": "Modeling"
        },
        {
            "location": "/#propagation",
            "text": "Implemented algorithms   Random walk   \nrandom_walk(G, h)   Random walk with restart   \nrandom_walk_with_restart(G, h, rp=0.7, n=-1)   Heat kernel   diffusion_kernel(G, h, rp=0.8, n=100)",
            "title": "Propagation"
        },
        {
            "location": "/#detail",
            "text": "image source:  Network propagation: a universal amplifier of genetic associations",
            "title": "detail"
        },
        {
            "location": "/#ipython-notebook-examples_1",
            "text": "Propagation",
            "title": "IPython notebook examples"
        },
        {
            "location": "/#utility-and-performance",
            "text": "The Id converter  GMT file manager  network and expression data sets.  numpy implementation of SPIA  node swap c extension for Hotnet2  multi-threading for MAGI",
            "title": "Utility and Performance"
        },
        {
            "location": "/#interactive-visualization",
            "text": "The interactive visualization for IPython notebook",
            "title": "Interactive Visualization"
        },
        {
            "location": "/#feature",
            "text": "__repr__  Implemented for most classes  dynamic visualization for networkx.Graph instance  visualizer for pathway object  visualizer for Gene ontology DAG.",
            "title": "Feature"
        },
        {
            "location": "/network_process/",
            "text": "Network process\n\n\nAPIs for querying and retrieval interaction network from public database. The return object are stored in networkx graph object.\n\n\nSTRING\n\n\nSingle or list molecular\n\n\nTo search interaction network related to STRING database, use the staticmethod \nSTRING.search(name, organism)\n .\n\n\n\n\nand each search result could be retrieved using its \nload\n method; the result of \nload\n method is a \nnetworkx.Graph\n with a additional \nplot\n method. Use the plot method to draw the graph.\n\n\n\n\nQuery Entire network\n\n\nAlso, download the total interaction network is available for certain organism. use \nSTRING.overall_network(organism)\n to retrieve the total interaction network to a networkx object.\n\n\n# This function returns a nx.Graph object G contain the entire network from string for species hsa.\nG = STRING.overall_graph(\"hsa\")\n\n\n\n\nBioGRID\n\n\nSingle or list of molecular\n\n\nSimilar to STRING, single or list molecular search is implemented in \nBioGRID.search\n, supports three type of id: [\nSymbol\n, \nExtrez\n, \npubmed\n].\n\n\n\n\nThe result is the \nnetworkx.Graph\n object with additional plot object.\n\n\n\n\nEntire networks\n\n\nUsing \nBioGRID.overall_network(organism)\n to retrieve the entire network.\n\n\nKEGG\n\n\nTo search and retrieve pathway from KEGG\n\n\n# use search_kegg to search kegg database\nres = PublicDatabase.search_kegg(name, organism=\"hsa\")\n# use load() method to parse the result\npath = res[0].load()\n# use plot to view the pathway.\n\n\n\n\nResult\n\n\n\n\nUnlike STRING and BioGRID, the KEGG, Reactome and WikiPathway object\nare stored in a tree-like object.\n\n\nReactome\n\n\nThe reactome API is integrated in the class \nPublicDatabase\n, use PublicDatabase to\n search Reactome database for pathways.\n\n\nres = PublicDatabase.search_reactome(\"jak\")\n\n\n\n\nresults(list of class of ReactomeResult)\n\n\n[source: Reactome\n  id: R-HSA-8950505\n BioPAX: False \n SBGN-PD: False \n description:b'Gene and protein expression by <span class=\"highlighting\" >JAK</span>-STAT signaling after Interleukin-12 stimulation',\n source: Reactome\n  id: R-HSA-6788467\n BioPAX: False \n SBGN-PD: False \n description:b'IL-6-type cytokine receptor ligand interactions',\n source: Reactome\n  id: R-HSA-877300\n BioPAX: False \n SBGN-PD: False \n description:b'Interferon gamma signaling',\n source: Reactome\n  id: R-HSA-913531\n BioPAX: False \n SBGN-PD: False \n description:b'Interferon Signaling',\n source: Reactome\n  id: R-HSA-982772\n BioPAX: False \n SBGN-PD: False \n description:b'Growth hormone receptor signaling']\n\n\n\n\nRetrieve and draw the pathway.\n\n\n# load\npathway = res[1].load()\n# draw\nph.draw()\n\n\n\n\nThe result pathway is drawn in the interactive region\n\n\n\n\nWikiPathway\n\n\nThe class \nPublicDatabase\n also implements \nsearch_wp\n API.\n\n\nPublicDatabase.search_wp(keyword, organism)\n\n\n\n\nwhich return a class of WikiPathwayResult instances, use load method to get\nthe pathway object. And draw to get quick preview of the pathway.\n\n\nresult[0].load().draw()\n\n\n\n\nExample\n\n\n# search\nres = PublicDatabase.search_wp(\"jak\")\n# load \npath = res[0].load()\n# draw\npath.draw()",
            "title": "Network process"
        },
        {
            "location": "/network_process/#network-process",
            "text": "APIs for querying and retrieval interaction network from public database. The return object are stored in networkx graph object.",
            "title": "Network process"
        },
        {
            "location": "/network_process/#string",
            "text": "Single or list molecular  To search interaction network related to STRING database, use the staticmethod  STRING.search(name, organism)  .   and each search result could be retrieved using its  load  method; the result of  load  method is a  networkx.Graph  with a additional  plot  method. Use the plot method to draw the graph.   Query Entire network  Also, download the total interaction network is available for certain organism. use  STRING.overall_network(organism)  to retrieve the total interaction network to a networkx object.  # This function returns a nx.Graph object G contain the entire network from string for species hsa.\nG = STRING.overall_graph(\"hsa\")",
            "title": "STRING"
        },
        {
            "location": "/network_process/#biogrid",
            "text": "Single or list of molecular  Similar to STRING, single or list molecular search is implemented in  BioGRID.search , supports three type of id: [ Symbol ,  Extrez ,  pubmed ].   The result is the  networkx.Graph  object with additional plot object.   Entire networks  Using  BioGRID.overall_network(organism)  to retrieve the entire network.",
            "title": "BioGRID"
        },
        {
            "location": "/network_process/#kegg",
            "text": "To search and retrieve pathway from KEGG  # use search_kegg to search kegg database\nres = PublicDatabase.search_kegg(name, organism=\"hsa\")\n# use load() method to parse the result\npath = res[0].load()\n# use plot to view the pathway.  Result   Unlike STRING and BioGRID, the KEGG, Reactome and WikiPathway object\nare stored in a tree-like object.",
            "title": "KEGG"
        },
        {
            "location": "/network_process/#reactome",
            "text": "The reactome API is integrated in the class  PublicDatabase , use PublicDatabase to\n search Reactome database for pathways.  res = PublicDatabase.search_reactome(\"jak\")  results(list of class of ReactomeResult)  [source: Reactome\n  id: R-HSA-8950505\n BioPAX: False \n SBGN-PD: False \n description:b'Gene and protein expression by <span class=\"highlighting\" >JAK</span>-STAT signaling after Interleukin-12 stimulation',\n source: Reactome\n  id: R-HSA-6788467\n BioPAX: False \n SBGN-PD: False \n description:b'IL-6-type cytokine receptor ligand interactions',\n source: Reactome\n  id: R-HSA-877300\n BioPAX: False \n SBGN-PD: False \n description:b'Interferon gamma signaling',\n source: Reactome\n  id: R-HSA-913531\n BioPAX: False \n SBGN-PD: False \n description:b'Interferon Signaling',\n source: Reactome\n  id: R-HSA-982772\n BioPAX: False \n SBGN-PD: False \n description:b'Growth hormone receptor signaling']  Retrieve and draw the pathway.  # load\npathway = res[1].load()\n# draw\nph.draw()  The result pathway is drawn in the interactive region",
            "title": "Reactome"
        },
        {
            "location": "/network_process/#wikipathway",
            "text": "The class  PublicDatabase  also implements  search_wp  API.  PublicDatabase.search_wp(keyword, organism)  which return a class of WikiPathwayResult instances, use load method to get\nthe pathway object. And draw to get quick preview of the pathway.  result[0].load().draw()  Example  # search\nres = PublicDatabase.search_wp(\"jak\")\n# load \npath = res[0].load()\n# draw\npath.draw()",
            "title": "WikiPathway"
        },
        {
            "location": "/enrichment/",
            "text": "Enrichment Analysis\n\n\nOverview\n\n\nEnrichment analysis aim to find functional set which are over-represented in \na large set of protein or genes. In this section, we will go through the supports\nenrichment, demonstrate the definition and the usage of each method. \n\n\nBasic class\n\n\nThis basic class of enrichment analysis is \nEnrichmentResult\n it self contains the \n result of certain type of enrichment analysis and subclass should at least\n rewrite the statistic method \nrun\n to perform the analysis.\n\n\nmethods\n\n\n\n\n\n\nrun\n : execute the enrichment analysis and return the instance of subclass contains\nthe analysis information\n\n\n\n\n\n\ntable\n : return the result pandas.Dataframe\n\n\n\n\n\n\nplot\n : plot the bar chart in the output area\n\n\n\n\n\n\ngraph\n : if the result set have certain relationship, this method return the graph of them.\nfor example, the Gene Ontology ORA subclass return the graph of GO DAG of significant sets.\n\n\n\n\n\n\nORA\n\n\nThe over-representation analysis is the most widely used enrichment analysis method, It use\nFisher's exact test to check whether certain functional set is over-represented in a large set\nof protein or genes.\n\n\nImplementation\n\n\nThe ORA methods is implemented in the analysis.ora\n\n\n# general ora method\nORA.run(study, pop, gene_set, adjust='fdr_bh')    \n\n\n\n\nwhere \nstudy\n is set of significant differential expressed genes or proteins,\n and \npop\n is the total annotated genes or proteins. the \ngene_set\n is a dict contains\nthe gene set name and contained genes like \n\n\n{\"B cell receptor pathway\": {\"CD22\", \"CD81\"...}...}\n\n\n\n\nExample\n\n\n# import necessary module\nfrom pypathway.analysis.ora import KEGG, ORA\nfrom pypathway.utils import ColorectalCancer, IdMapping, GMTUtils\n\n# load a gene_set from a gmt file\ngmt = GMTUtils.parse_gmt_file(\"../../tests/gmt_file/h.all.v6.0.entrez.gmt\")\n\n# load data set\nc = ColorectalCancer()\n\n# perform general ORA test\nres_h = ORA.run(c.deg_list, c.background, gmt)\n\n# view result table\nres_h.table.head()\n\n\n\n\nThe result table (In IPython notebook):\n\n\n\n  \n\n    \n\n      \n\n      \nname\n\n      \nmapped\n\n      \nnumber in study\n\n      \np-value\n\n      \nfdr\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nHALLMARK_GLYCOLYSIS\n\n      \n184\n\n      \n91\n\n      \n9.956407e-08\n\n      \n3.555860e-07\n\n    \n\n    \n\n      \n1\n\n      \nHALLMARK_APICAL_JUNCTION\n\n      \n185\n\n      \n97\n\n      \n7.750142e-10\n\n      \n3.748583e-09\n\n    \n\n    \n\n      \n2\n\n      \nHALLMARK_MYC_TARGETS_V1\n\n      \n173\n\n      \n48\n\n      \n8.377692e-01\n\n      \n9.106187e-01\n\n    \n\n    \n\n      \n3\n\n      \nHALLMARK_COAGULATION\n\n      \n131\n\n      \n64\n\n      \n1.237516e-05\n\n      \n3.093790e-05\n\n    \n\n    \n\n      \n4\n\n      \nHALLMARK_MTORC1_SIGNALING\n\n      \n176\n\n      \n90\n\n      \n1.551015e-08\n\n      \n5.965443e-08\n\n    \n\n  \n\n\n\n\n\n# barplot\nres_h.plot()\n\n\n\n\n\n\nSpecific ORA\n\n\nFor KEGG, REACTOME and GO, there are specific class implement for them. For the convienice of geneset query and \n\n\n\n\nKEGG\n \n\n\n\n\n# rather than input specific gene set, organism is accepted and geneset will be retrieved.\nr_kg = KEGG.run(c.deg_list, c.background, 'hsa')\n\n\n\n\n\n\nReactome\n\n\n\n\n# Reactome official API is used. note that the background is the whole Reactome\n# library, if background set required, use Reactome GMT file and ORA class \nr = Reactome.run(sybs, organism='Homo sapiens')\n\n\n\n\n\n\nGene Ontology\n\n\n\n\n# Gene ontology analysis require additional a assoc file.\n# IdMapping class could be used to generate this file\n# c.background is to background gene list of certain study\nr = IdMapping.convert_to_dict(input_id=c.background, source='ENTREZID', target=\"GO\", organism='hsa')\n# and run the analysis\n# [str(x) for x in c.deg_list]: study\n# [str(x) for x in c.background]: background\n# r: the assoc dict\n# obo=path + 'go-basic.obo': the path to the obo file\nrg = GO.run([str(x) for x in c.deg_list], [str(x) for x in c.background], r, obo=path + 'go-basic.obo')\n\n\n\n\nThe gene ontology enrichment analysis provide the graph overview of the analysis\n\n\n\n\nGSEA\n\n\nThe Gene Set Enrichment Analysis, is introduced in paper:\n\n\n\n\nGene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles\n\n\n\n\nat \nPNAS\n\n\nThis class is implement via \nGSEApy\n\n\nUsage\n\n\n# gene_exp is the expression dataframe\n# class_vector is the define of the experiment\ngs_res = gp.gsea(data=gene_exp, gene_sets='KEGG_2016', cls=class_vector, \n                 permutation_type='phenotype', #set permutation_type to phenotype when \n                 outdir='gsea_reprot', method='signal_to_noise', format='png')\n\n\n\n\nmore detail information is described in the \nexample/analysis/GSEA.ipynb\n\n\nSPIA\n\n\nThe Signaling Pathway Impact Analysis, is introduced in paper:\n\n\n\n\nA novel signaling pathway impact analysis\n\n\n\n\nwe implement this algorithm in Python.\n\n\nUsage\n\n\nr = SPIA.run(de=c.deg, all=c.background)\n# de: a dict, key: gene, value: fold-change\n# the idtype is entrez. use IDMapping to convert\n\n\n\n\nEnrichnet\n\n\nThe Enrichnet algorithm is introduced in paper\n\n\n\n\nEnrichNet: network-based gene set enrichment analysis\n\n\n\n\nwe implement the Python API for Enrichnet HTTP service.\n\n\nUsage\n\n\nrun(genesets, idtype='hgnc_symbol', pathdb='kegg', graph='string')\n# genesets: the gene list used to run the analysis\n# idtype: input id type\n# the pathlib: function set library\n# graph: the graph",
            "title": "Enrichment"
        },
        {
            "location": "/enrichment/#enrichment-analysis",
            "text": "",
            "title": "Enrichment Analysis"
        },
        {
            "location": "/enrichment/#overview",
            "text": "Enrichment analysis aim to find functional set which are over-represented in \na large set of protein or genes. In this section, we will go through the supports\nenrichment, demonstrate the definition and the usage of each method.",
            "title": "Overview"
        },
        {
            "location": "/enrichment/#basic-class",
            "text": "This basic class of enrichment analysis is  EnrichmentResult  it self contains the \n result of certain type of enrichment analysis and subclass should at least\n rewrite the statistic method  run  to perform the analysis.",
            "title": "Basic class"
        },
        {
            "location": "/enrichment/#methods",
            "text": "run  : execute the enrichment analysis and return the instance of subclass contains\nthe analysis information    table  : return the result pandas.Dataframe    plot  : plot the bar chart in the output area    graph  : if the result set have certain relationship, this method return the graph of them.\nfor example, the Gene Ontology ORA subclass return the graph of GO DAG of significant sets.",
            "title": "methods"
        },
        {
            "location": "/enrichment/#ora",
            "text": "The over-representation analysis is the most widely used enrichment analysis method, It use\nFisher's exact test to check whether certain functional set is over-represented in a large set\nof protein or genes.",
            "title": "ORA"
        },
        {
            "location": "/enrichment/#implementation",
            "text": "The ORA methods is implemented in the analysis.ora  # general ora method\nORA.run(study, pop, gene_set, adjust='fdr_bh')      where  study  is set of significant differential expressed genes or proteins,\n and  pop  is the total annotated genes or proteins. the  gene_set  is a dict contains\nthe gene set name and contained genes like   {\"B cell receptor pathway\": {\"CD22\", \"CD81\"...}...}",
            "title": "Implementation"
        },
        {
            "location": "/enrichment/#example",
            "text": "# import necessary module\nfrom pypathway.analysis.ora import KEGG, ORA\nfrom pypathway.utils import ColorectalCancer, IdMapping, GMTUtils\n\n# load a gene_set from a gmt file\ngmt = GMTUtils.parse_gmt_file(\"../../tests/gmt_file/h.all.v6.0.entrez.gmt\")\n\n# load data set\nc = ColorectalCancer()\n\n# perform general ORA test\nres_h = ORA.run(c.deg_list, c.background, gmt)\n\n# view result table\nres_h.table.head()  The result table (In IPython notebook):  \n   \n     \n       \n       name \n       mapped \n       number in study \n       p-value \n       fdr \n     \n   \n   \n     \n       0 \n       HALLMARK_GLYCOLYSIS \n       184 \n       91 \n       9.956407e-08 \n       3.555860e-07 \n     \n     \n       1 \n       HALLMARK_APICAL_JUNCTION \n       185 \n       97 \n       7.750142e-10 \n       3.748583e-09 \n     \n     \n       2 \n       HALLMARK_MYC_TARGETS_V1 \n       173 \n       48 \n       8.377692e-01 \n       9.106187e-01 \n     \n     \n       3 \n       HALLMARK_COAGULATION \n       131 \n       64 \n       1.237516e-05 \n       3.093790e-05 \n     \n     \n       4 \n       HALLMARK_MTORC1_SIGNALING \n       176 \n       90 \n       1.551015e-08 \n       5.965443e-08 \n     \n     # barplot\nres_h.plot()",
            "title": "Example"
        },
        {
            "location": "/enrichment/#specific-ora",
            "text": "For KEGG, REACTOME and GO, there are specific class implement for them. For the convienice of geneset query and    KEGG     # rather than input specific gene set, organism is accepted and geneset will be retrieved.\nr_kg = KEGG.run(c.deg_list, c.background, 'hsa')   Reactome   # Reactome official API is used. note that the background is the whole Reactome\n# library, if background set required, use Reactome GMT file and ORA class \nr = Reactome.run(sybs, organism='Homo sapiens')   Gene Ontology   # Gene ontology analysis require additional a assoc file.\n# IdMapping class could be used to generate this file\n# c.background is to background gene list of certain study\nr = IdMapping.convert_to_dict(input_id=c.background, source='ENTREZID', target=\"GO\", organism='hsa')\n# and run the analysis\n# [str(x) for x in c.deg_list]: study\n# [str(x) for x in c.background]: background\n# r: the assoc dict\n# obo=path + 'go-basic.obo': the path to the obo file\nrg = GO.run([str(x) for x in c.deg_list], [str(x) for x in c.background], r, obo=path + 'go-basic.obo')  The gene ontology enrichment analysis provide the graph overview of the analysis",
            "title": "Specific ORA"
        },
        {
            "location": "/enrichment/#gsea",
            "text": "The Gene Set Enrichment Analysis, is introduced in paper:   Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles   at  PNAS  This class is implement via  GSEApy",
            "title": "GSEA"
        },
        {
            "location": "/enrichment/#usage",
            "text": "# gene_exp is the expression dataframe\n# class_vector is the define of the experiment\ngs_res = gp.gsea(data=gene_exp, gene_sets='KEGG_2016', cls=class_vector, \n                 permutation_type='phenotype', #set permutation_type to phenotype when \n                 outdir='gsea_reprot', method='signal_to_noise', format='png')  more detail information is described in the  example/analysis/GSEA.ipynb",
            "title": "Usage"
        },
        {
            "location": "/enrichment/#spia",
            "text": "The Signaling Pathway Impact Analysis, is introduced in paper:   A novel signaling pathway impact analysis   we implement this algorithm in Python.",
            "title": "SPIA"
        },
        {
            "location": "/enrichment/#usage_1",
            "text": "r = SPIA.run(de=c.deg, all=c.background)\n# de: a dict, key: gene, value: fold-change\n# the idtype is entrez. use IDMapping to convert",
            "title": "Usage"
        },
        {
            "location": "/enrichment/#enrichnet",
            "text": "The Enrichnet algorithm is introduced in paper   EnrichNet: network-based gene set enrichment analysis   we implement the Python API for Enrichnet HTTP service.",
            "title": "Enrichnet"
        },
        {
            "location": "/enrichment/#usage_2",
            "text": "run(genesets, idtype='hgnc_symbol', pathdb='kegg', graph='string')\n# genesets: the gene list used to run the analysis\n# idtype: input id type\n# the pathlib: function set library\n# graph: the graph",
            "title": "Usage"
        },
        {
            "location": "/modelling/",
            "text": "MAGI\n\n\nPaper\n\n\n\n\nThe discovery of integrated gene networks for autism and related disorders\n\n\n\n\nOriginal C Implementation\n\n\nhttps://eichlerlab.gs.washington.edu/MAGI/\n The source and example are available in this website.\n\n\nOverview\n\n\nThe C implementation only use one thread and lacks exception handling. We provide the Python interface with modified multi-process model and File IO exception handler.\n\n\nUsage\n\n\nThe original C implementation are migrate into Python C extension, The \nMAGI\n class are used to execute the \npathway_select\n and the \nclustring\n. The visualization methods are provided to plot the \nmodule\n network.\n\n\npathway_select\n\n\nThe statistic method \nMAGI.select_pathway\n are used to generate the seed pathway use color-coding algorithm.\n\n\nselect_pathway(ppi, case, coExpId, coExpMat, ctrl, length, filter=None, process=8)\n\n\n\n\nParameter\n\n\n \nppi\n: the Protein-protein interaction network, example: \nStringNew_HPRD\n.\n\n \ncase\n: the case denote mutation list example: \nID_2_Autism_4_Severe_Missense.Clean_WithNew\n\n\n \ncoExpId\n: The input gives the order of each gene appearing in the coExpression matrix. example \nGeneCoExpresion_ID\n\n\n \ncoExpMat\n: the Pairwise gene coexpression values. example: \nadj1.csv.Tab.BinaryFormat\n.\n\n \nctrl\n: The number of mutations in each gene in controls. example: \nNew_ESP_Sereve\n\n\n \nfilter\n: optional, remove set of the gene in PPI.\n* \nlength\n: the length of each genes, example: \nGene_Name_Length\n\n\nExample\n\n\nnote\n: all the file is in the \n.\n folder. if not, should use relative or absolute path.\n\n\n# path is the path to the assets file.\nMAGI.select_pathway(path + 'StringNew_HPRD.txt', path + 'ID_2_Autism_4_Severe_Missense.Clean_WithNew.txt',\n                   path + 'GeneCoExpresion_ID.txt', path + 'adj1.csv.Tab.BinaryFormat', path + 'New_ESP_Sereve.txt',\n                   path + 'Gene_Name_Length.txt')\n\n\n\n\nThe seed file, random list file will be written to the \ncache\n dir.\n\n\nClustering\n\n\nthe statistic method \nMAGI.clustering\n are used to cluster the seed pathway generated in the last step.\n\n\ndef cluster(ppi, coExpId, coExpMat, upper_mutation_on_control,\n                min_size_of_module, max_size_of_module, min_ratio_of_seed,\n                minCoExpr=None, avgCoExpr=None, avgDensity=None, seed=None, score=None):\n\n\n\n\n\nParameter\n\n\n \nppi\n: the Protein-protein interaction network, example: \nStringNew_HPRD\n.\n\n \ncoExpId\n: The input gives the order of each gene appearing in the coExpression matrix. example \nGeneCoExpresion_ID\n\n\n \ncoExpMat\n: the Pairwise gene coexpression values. example: \nadj1.csv.Tab.BinaryFormat\n.\n\n \nupper_mutation_on_control\n: The total number of mutations in control's allowed.\n\n \nmin_size_of_module\n:     The minimum number of genes in the module\n\n \nmax_size_of_module\n:     The maximum number of genes in the module\n\n \nmin_ratio_of_seed\n: For each seed type the top percentage of the score from maximum score of the seed allowed (in the paper \n0.5\n was used)\n\n \nminCoExpr\n: The minimum pair-wise coexpression value per gene allowed (the default is 0.01, i.e. \nr^2>0.01\n, which is the median coexpression value in the input \nadj1.csv.Tab.BinaryFormat\n)\n\n \navgCoExpr\n: The minimum average coexpression of the modules allowed (the default is \n0.415\n)\n\n \navgDensity\n:         The minimum avergae PPI density of the modules allowed (the default is 0.08)\n\n \nseed\n: if the \nMAGI.select_pathway\n is called before, than ignore this. is the seed is generate by CLI PathwaySelect, use the seed file path here\n\n \nscore\n: similar to \nseed\n, input CLI generate score file path else None;\n\n\nExample\n\n\nresult = MAGI.cluster(path + 'StringNew_HPRD.txt', path + 'GeneCoExpresion_ID.txt', path + 'adj1.csv.Tab.BinaryFormat', 2, 5, 100, 0.5)\n\n\n\n\nThe result a list of \nMAGIResult\n class.\n\n\n# plot the result\nresult[0].plot()",
            "title": "Modelling"
        },
        {
            "location": "/modelling/#magi",
            "text": "",
            "title": "MAGI"
        },
        {
            "location": "/modelling/#paper",
            "text": "The discovery of integrated gene networks for autism and related disorders",
            "title": "Paper"
        },
        {
            "location": "/modelling/#original-c-implementation",
            "text": "https://eichlerlab.gs.washington.edu/MAGI/  The source and example are available in this website.",
            "title": "Original C Implementation"
        },
        {
            "location": "/modelling/#overview",
            "text": "The C implementation only use one thread and lacks exception handling. We provide the Python interface with modified multi-process model and File IO exception handler.",
            "title": "Overview"
        },
        {
            "location": "/modelling/#usage",
            "text": "The original C implementation are migrate into Python C extension, The  MAGI  class are used to execute the  pathway_select  and the  clustring . The visualization methods are provided to plot the  module  network.",
            "title": "Usage"
        },
        {
            "location": "/modelling/#pathway_select",
            "text": "The statistic method  MAGI.select_pathway  are used to generate the seed pathway use color-coding algorithm.  select_pathway(ppi, case, coExpId, coExpMat, ctrl, length, filter=None, process=8)  Parameter    ppi : the Protein-protein interaction network, example:  StringNew_HPRD .   case : the case denote mutation list example:  ID_2_Autism_4_Severe_Missense.Clean_WithNew    coExpId : The input gives the order of each gene appearing in the coExpression matrix. example  GeneCoExpresion_ID    coExpMat : the Pairwise gene coexpression values. example:  adj1.csv.Tab.BinaryFormat .   ctrl : The number of mutations in each gene in controls. example:  New_ESP_Sereve    filter : optional, remove set of the gene in PPI.\n*  length : the length of each genes, example:  Gene_Name_Length  Example  note : all the file is in the  .  folder. if not, should use relative or absolute path.  # path is the path to the assets file.\nMAGI.select_pathway(path + 'StringNew_HPRD.txt', path + 'ID_2_Autism_4_Severe_Missense.Clean_WithNew.txt',\n                   path + 'GeneCoExpresion_ID.txt', path + 'adj1.csv.Tab.BinaryFormat', path + 'New_ESP_Sereve.txt',\n                   path + 'Gene_Name_Length.txt')  The seed file, random list file will be written to the  cache  dir.",
            "title": "pathway_select"
        },
        {
            "location": "/modelling/#clustering",
            "text": "the statistic method  MAGI.clustering  are used to cluster the seed pathway generated in the last step.  def cluster(ppi, coExpId, coExpMat, upper_mutation_on_control,\n                min_size_of_module, max_size_of_module, min_ratio_of_seed,\n                minCoExpr=None, avgCoExpr=None, avgDensity=None, seed=None, score=None):  Parameter    ppi : the Protein-protein interaction network, example:  StringNew_HPRD .   coExpId : The input gives the order of each gene appearing in the coExpression matrix. example  GeneCoExpresion_ID    coExpMat : the Pairwise gene coexpression values. example:  adj1.csv.Tab.BinaryFormat .   upper_mutation_on_control : The total number of mutations in control's allowed.   min_size_of_module :     The minimum number of genes in the module   max_size_of_module :     The maximum number of genes in the module   min_ratio_of_seed : For each seed type the top percentage of the score from maximum score of the seed allowed (in the paper  0.5  was used)   minCoExpr : The minimum pair-wise coexpression value per gene allowed (the default is 0.01, i.e.  r^2>0.01 , which is the median coexpression value in the input  adj1.csv.Tab.BinaryFormat )   avgCoExpr : The minimum average coexpression of the modules allowed (the default is  0.415 )   avgDensity :         The minimum avergae PPI density of the modules allowed (the default is 0.08)   seed : if the  MAGI.select_pathway  is called before, than ignore this. is the seed is generate by CLI PathwaySelect, use the seed file path here   score : similar to  seed , input CLI generate score file path else None;  Example  result = MAGI.cluster(path + 'StringNew_HPRD.txt', path + 'GeneCoExpresion_ID.txt', path + 'adj1.csv.Tab.BinaryFormat', 2, 5, 100, 0.5)  The result a list of  MAGIResult  class.  # plot the result\nresult[0].plot()",
            "title": "Clustering"
        },
        {
            "location": "/propagation/",
            "text": "Network Propagation\n\n\nthis module implements three algorithms: \nrandom walk\n, \nrandom walk with restart\n and \nheat kernel\n. The \nimplementation of this module is according to paper\n\n\n\n\nNetwork propagation: a universal amplifier of genetic associations\n\n\n\n\nAll these method start with a vector = |V| and simulate the heat diffuse process in the network.\nthe difference between these methods are list in the following table (from above paper).\n\n\n\n\nRandom Walk\n\n\nAPI\n\n\ndef random_walk(G: nx.Graph, heat: list, n: int = -1, threshold: float = 1e-6) -> nx.Graph\n\n\n\n\nArguments:\n\n\n\n\nG: nx.Graph\n : the input graph.\n\n\nheat\n : the heat vector, length = |V|.\n\n\nn: int = -1\n : the time random walk repeats, if n==-1, the loop will stop when the\n    threshold is reached.\n\n\nthreshold\n: the threshold check whether the steady state is reached.\n\n\n\n\nReturn value\n\n\nnx.Graph (copied) with node property \nheat\n with the result heat of each node.\n\n\nExample\n\n\n# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: random_walk(G, h).node\n\nOut [5]: \n{1: {'heat': 0.33333342635070995},\n 2: {'heat': 0.49999990698262176},\n 3: {'heat': 0.3333333333333327},\n 4: {'heat': 0.3333332403159554},\n 5: {'heat': 0.50000009301737625}}\n\n\n\n\nRandom Walk with Restart (RWR)\n\n\nAPI\n\n\ndef random_walk_with_restart(G: nx.Graph, heat: list, rp: float, n: int = -1, threshold: float = 1e-6) -> nx.Graph:\n\n\n\n\nArguments:\n\n\n\n\nG: nx.Graph\n : the input graph.\n\n\nheat\n : the heat vector, length = |V|.\n\n\nn: int = -1\n : the time random walk with restart repeats, if n==-1, the loop will stop when the\n    threshold is reached.\n\n\nrp\n: restart probability.\n\n\nthreshold\n: the threshold check whether the steady state is reached.\n\n\n\n\nReturn value\n\n\nnx.Graph (copied) with node property \nheat\n with the result heat of each node\n\n\nExample\n\n\n# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: random_walk_with_restart(G, h, rp=0.7, n=-1).node\n\nOut [5]: \n{1: {'heat': 0.18859903381642515},\n 2: {'heat': 0.76309178743961337},\n 3: {'heat': 0.096618357487922704},\n 4: {'heat': 0.74859903381642512},\n 5: {'heat': 0.20309178743961354}}\n\n\n\n\nHeat kernel\n\n\nAPI\n\n\ndef diffusion_kernel(G: nx.Graph, heat: list, rp: float, n: int, threshold: float = 1e-6) -> nx.Graph:\n\n\n\n\nArguments:\n\n\n\n\nG: nx.Graph\n : the input graph.\n\n\nheat\n : the heat vector, length = |V|.\n\n\nn: int = -1\n : the time random walk with restart repeats.\n\n\nrp\n: restart probability.\n\n\n\n\nReturn value\n\n\nnx.Graph (copied) with node property \nheat\n with the result heat of each node\n\n\nExample\n\n\n# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: diffusion_kernel(G, h, rp=0.8, n=100).node\n\nOut [5]: \n{1: {'heat': 0.42138736822730222},\n 2: {'heat': 0.38934416321338194},\n 3: {'heat': 0.32359870881215813},\n 4: {'heat': 0.47852257848932078},\n 5: {'heat': 0.38714718125782877}}\n\n\n\n\nExample Notebook\n\n\nthe example notebook is available at \nGithub\n.",
            "title": "propagation"
        },
        {
            "location": "/propagation/#network-propagation",
            "text": "this module implements three algorithms:  random walk ,  random walk with restart  and  heat kernel . The \nimplementation of this module is according to paper   Network propagation: a universal amplifier of genetic associations   All these method start with a vector = |V| and simulate the heat diffuse process in the network.\nthe difference between these methods are list in the following table (from above paper).",
            "title": "Network Propagation"
        },
        {
            "location": "/propagation/#random-walk",
            "text": "",
            "title": "Random Walk"
        },
        {
            "location": "/propagation/#api",
            "text": "def random_walk(G: nx.Graph, heat: list, n: int = -1, threshold: float = 1e-6) -> nx.Graph",
            "title": "API"
        },
        {
            "location": "/propagation/#arguments",
            "text": "G: nx.Graph  : the input graph.  heat  : the heat vector, length = |V|.  n: int = -1  : the time random walk repeats, if n==-1, the loop will stop when the\n    threshold is reached.  threshold : the threshold check whether the steady state is reached.",
            "title": "Arguments:"
        },
        {
            "location": "/propagation/#return-value",
            "text": "nx.Graph (copied) with node property  heat  with the result heat of each node.",
            "title": "Return value"
        },
        {
            "location": "/propagation/#example",
            "text": "# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: random_walk(G, h).node\n\nOut [5]: \n{1: {'heat': 0.33333342635070995},\n 2: {'heat': 0.49999990698262176},\n 3: {'heat': 0.3333333333333327},\n 4: {'heat': 0.3333332403159554},\n 5: {'heat': 0.50000009301737625}}",
            "title": "Example"
        },
        {
            "location": "/propagation/#random-walk-with-restart-rwr",
            "text": "",
            "title": "Random Walk with Restart (RWR)"
        },
        {
            "location": "/propagation/#api_1",
            "text": "def random_walk_with_restart(G: nx.Graph, heat: list, rp: float, n: int = -1, threshold: float = 1e-6) -> nx.Graph:",
            "title": "API"
        },
        {
            "location": "/propagation/#arguments_1",
            "text": "G: nx.Graph  : the input graph.  heat  : the heat vector, length = |V|.  n: int = -1  : the time random walk with restart repeats, if n==-1, the loop will stop when the\n    threshold is reached.  rp : restart probability.  threshold : the threshold check whether the steady state is reached.",
            "title": "Arguments:"
        },
        {
            "location": "/propagation/#return-value_1",
            "text": "nx.Graph (copied) with node property  heat  with the result heat of each node",
            "title": "Return value"
        },
        {
            "location": "/propagation/#example_1",
            "text": "# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: random_walk_with_restart(G, h, rp=0.7, n=-1).node\n\nOut [5]: \n{1: {'heat': 0.18859903381642515},\n 2: {'heat': 0.76309178743961337},\n 3: {'heat': 0.096618357487922704},\n 4: {'heat': 0.74859903381642512},\n 5: {'heat': 0.20309178743961354}}",
            "title": "Example"
        },
        {
            "location": "/propagation/#heat-kernel",
            "text": "",
            "title": "Heat kernel"
        },
        {
            "location": "/propagation/#api_2",
            "text": "def diffusion_kernel(G: nx.Graph, heat: list, rp: float, n: int, threshold: float = 1e-6) -> nx.Graph:",
            "title": "API"
        },
        {
            "location": "/propagation/#arguments_2",
            "text": "G: nx.Graph  : the input graph.  heat  : the heat vector, length = |V|.  n: int = -1  : the time random walk with restart repeats.  rp : restart probability.",
            "title": "Arguments:"
        },
        {
            "location": "/propagation/#return-value_2",
            "text": "nx.Graph (copied) with node property  heat  with the result heat of each node",
            "title": "Return value"
        },
        {
            "location": "/propagation/#example_2",
            "text": "# the graph\nIn [3]: G = nx.Graph([[1, 2], [2, 3], [3, 5], [2, 5], [1, 4], [4, 5]])\n# the heat\nIn [4]: h = np.array([0, 1, 0, 1, 0])\nIn [5]: diffusion_kernel(G, h, rp=0.8, n=100).node\n\nOut [5]: \n{1: {'heat': 0.42138736822730222},\n 2: {'heat': 0.38934416321338194},\n 3: {'heat': 0.32359870881215813},\n 4: {'heat': 0.47852257848932078},\n 5: {'heat': 0.38714718125782877}}",
            "title": "Example"
        },
        {
            "location": "/propagation/#example-notebook",
            "text": "the example notebook is available at  Github .",
            "title": "Example Notebook"
        },
        {
            "location": "/netviz/",
            "text": "Overview\n\n\nThis is the inner module of pynet and a dynamic visualizer for networkx graph. With several function like  tooltips, highlight and node modification.\n\n\n\n\nUsage\n\n\nInputs\n\n\nThe class \nFromNetworkx\n receive \nnetworks.Graph\n or \nnetworks.DiGraph\n instance, and plot as a HTML widget in the output area.\nThe difference between \nGraph\n and \nDiGraph\n is the arrow rendered in the target.\n\n\nExample\n\n\nFromNetworkX(nx.complete_graph(5)).plot()\n\n\n\n\nThis example generate a five node Graph and render.\n\n\n \n\n\nThe layout\n\n\nThe layout algorithm is mainly \nspring_layout\n. if the node number is less then 20, the module will use \ncose-bilkent\n implementation. Else the \nnx.spring_layout\n is used for speed concern.\n\n\nIf the graph is highly connected, the layout algorithm may have poor performance\n\n\nBasic interactive feature\n\n\nTooltips\n\n\nif any \ntooltip\n item are in the node\u2019s property, a tooltip will  appear when mouse hang over the node. the tooltip accepts a \ndict\n like \n\n\n{\u201cFIRST_ATTRITUTE\u201d: \u201cFIRST_VALUE\u201d, \u201cSECOND_ATTRIBUTE\u201d: \u201cSECOND_VALUE\u201d}\n\n\n\n\nand displays:\n\n\nFIRST_ATTRITUTE: FIRST_VALUE\nSECOND_ATTRIBUTE: SECOND_VALUE\n\n\n\n\nlook likes:\n\n\n\n\nThe cxtmenu\n\n\nif left click at certain node, a cxtmenu will be displayed with mark, remove and expand(may not available if not implemented).\n\n\n\nThe DAG visualizer for GO\n\n\nSpecially for Gene Ontology, the DAG plotter is prepared with dagre layout.\n\n\nExample: \n\n\nTodo\n\n\nStyle\n\n\nThe \nFromNetworkx\n receives style like {\u2018node\u2019: {\u2026}, \u2018edge\u2019: {\u2026}, \u2018spring_length\u2019: {\u2026}}\nor several presets are available in \nStylePresets\n\nfor example:\n\n\nORANGE_CENTERED_LABEL = {\n        'node': {'label': 'data(label)',\n                 'width': 24,\n                 'height': 24,\n                 'font-size': '-1em',\n                 'font-weight': 2,\n                 'background-color': '#F69924',\n                 'border-width': 2,\n                 'border-color': 'white',\n                 'text-valign': 'center',\n                 'text-halign': 'center',\n                 'color': 'white'\n                 },\n        'edge': {\n            'width': 3,\n            'line-color': '#F69924'\n        },\n        'spring_length': 50\n    }\n\n\n\n\nCaution\n\n\nMaximum node and edge count\n\n\nDue to the performance issue cause by JavaScript and Cytoscape.js, and Graph whose node number > 2k or edge > 5k will cause browser long time 100 percent CPU usage.",
            "title": "Visualization"
        },
        {
            "location": "/netviz/#overview",
            "text": "This is the inner module of pynet and a dynamic visualizer for networkx graph. With several function like  tooltips, highlight and node modification.",
            "title": "Overview"
        },
        {
            "location": "/netviz/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/netviz/#inputs",
            "text": "The class  FromNetworkx  receive  networks.Graph  or  networks.DiGraph  instance, and plot as a HTML widget in the output area.\nThe difference between  Graph  and  DiGraph  is the arrow rendered in the target.",
            "title": "Inputs"
        },
        {
            "location": "/netviz/#example",
            "text": "FromNetworkX(nx.complete_graph(5)).plot()  This example generate a five node Graph and render.",
            "title": "Example"
        },
        {
            "location": "/netviz/#the-layout",
            "text": "The layout algorithm is mainly  spring_layout . if the node number is less then 20, the module will use  cose-bilkent  implementation. Else the  nx.spring_layout  is used for speed concern.  If the graph is highly connected, the layout algorithm may have poor performance",
            "title": "The layout"
        },
        {
            "location": "/netviz/#basic-interactive-feature",
            "text": "",
            "title": "Basic interactive feature"
        },
        {
            "location": "/netviz/#tooltips",
            "text": "if any  tooltip  item are in the node\u2019s property, a tooltip will  appear when mouse hang over the node. the tooltip accepts a  dict  like   {\u201cFIRST_ATTRITUTE\u201d: \u201cFIRST_VALUE\u201d, \u201cSECOND_ATTRIBUTE\u201d: \u201cSECOND_VALUE\u201d}  and displays:  FIRST_ATTRITUTE: FIRST_VALUE\nSECOND_ATTRIBUTE: SECOND_VALUE  look likes:",
            "title": "Tooltips"
        },
        {
            "location": "/netviz/#the-cxtmenu",
            "text": "if left click at certain node, a cxtmenu will be displayed with mark, remove and expand(may not available if not implemented).",
            "title": "The cxtmenu"
        },
        {
            "location": "/netviz/#the-dag-visualizer-for-go",
            "text": "Specially for Gene Ontology, the DAG plotter is prepared with dagre layout.  Example:",
            "title": "The DAG visualizer for GO"
        },
        {
            "location": "/netviz/#todo",
            "text": "",
            "title": "Todo"
        },
        {
            "location": "/netviz/#style",
            "text": "The  FromNetworkx  receives style like {\u2018node\u2019: {\u2026}, \u2018edge\u2019: {\u2026}, \u2018spring_length\u2019: {\u2026}}\nor several presets are available in  StylePresets \nfor example:  ORANGE_CENTERED_LABEL = {\n        'node': {'label': 'data(label)',\n                 'width': 24,\n                 'height': 24,\n                 'font-size': '-1em',\n                 'font-weight': 2,\n                 'background-color': '#F69924',\n                 'border-width': 2,\n                 'border-color': 'white',\n                 'text-valign': 'center',\n                 'text-halign': 'center',\n                 'color': 'white'\n                 },\n        'edge': {\n            'width': 3,\n            'line-color': '#F69924'\n        },\n        'spring_length': 50\n    }",
            "title": "Style"
        },
        {
            "location": "/netviz/#caution",
            "text": "",
            "title": "Caution"
        },
        {
            "location": "/netviz/#maximum-node-and-edge-count",
            "text": "Due to the performance issue cause by JavaScript and Cytoscape.js, and Graph whose node number > 2k or edge > 5k will cause browser long time 100 percent CPU usage.",
            "title": "Maximum node and edge count"
        }
    ]
}